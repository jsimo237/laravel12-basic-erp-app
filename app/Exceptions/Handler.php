<?php

namespace App\Exceptions;

use Illuminate\Auth\AuthenticationException;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Illuminate\Http\Request;
use Illuminate\Session\TokenMismatchException;
use Illuminate\Support\Arr;
use Illuminate\Validation\ValidationException;
use Neomerx\JsonApi\Exceptions\JsonApiException;
use Spatie\Permission\Exceptions\UnauthorizedException as SpatiePermissionException;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Throwable;


class Handler extends ExceptionHandler
{
    /**
     * The list of the inputs that are never flashed to the session on validation exceptions.
     *
     * @var array<int, string>
     */
    protected $dontFlash = [
        'current_password',
        'password',
        'password_confirmation',
    ];

    /**
     * A list of the exception types that are not reported.
     *
     * @var array<int, class-string<Throwable>>
     */
    protected $dontReport = [
        JsonApiException::class,
    ];

    public function report(Throwable $e)
    {
        parent::report($e); // TODO: Change the autogenerated stub
    }

    protected function customRegister(): Handler
    {
        return  $this->renderable(function (\Exception $exception, Request $request) {

            $instance = get_class($exception); // "\Spatie\Permission\Exceptions\UnauthorizedException"
            $response = ["message" => "Erreur" , 'success' => false];
            //  $status = $exception->getCode();



            if ($exception instanceof ValidationException){
                $response['errors'] = Arr::map(
                    $exception->validator->errors()->messages(),
                    fn($error,$key) =>  $error[0]
                );
            }

            $code = $exception?->getCode();

            $status = match($instance) {
                NotFoundHttpException::class, ModelNotFoundException::class => Response::HTTP_NOT_FOUND,
                AuthenticationException::class => Response::HTTP_UNAUTHORIZED,
                TokenMismatchException::class => Response::HTTP_CONFLICT,
                AccessDeniedHttpException::class,SpatiePermissionException::class => Response::HTTP_FORBIDDEN,
                ValidationException::class => Response::HTTP_UNPROCESSABLE_ENTITY,
                default => (is_numeric($code) && $code != 0) ? $code : Response::HTTP_INTERNAL_SERVER_ERROR
            };

            $getMessage = function ($message) use ($exception){
                return app()->isLocal() ? $exception->getMessage() : $message;
            };

            $message = match($instance) {
                NotFoundHttpException::class,ModelNotFoundException::class => $getMessage("La page/ressource que vous demandez n'existe pas ou a été supprimé."),
                AuthenticationException::class => $getMessage("Vous devez vous connecté pour continuer."),
                \Illuminate\Database\QueryException::class => $getMessage("Erreur fatale dans les données."),
                default =>  $getMessage("Une erreur imprévue est survenue lors de la demande")
            };

            // dd($status,get_class($exception),$exception->getMessage());

            if ($request->ajax() or $request->wantsJson() or  $request->is('api/*')){
                $response['message'] = $message;

                if (app()->isLocal()){
                    $response['exception'] = format_exception_message($exception);
                    $response['trace'] = $exception->getTraceAsString();
                }
                return response()->json($response, $status);
            }
        });
    }

    /**
     * Register the exception handling callbacks for the application.
     */
    public function register(): void {
       $this->customRegister();

       // TODO add code here
    }
}
